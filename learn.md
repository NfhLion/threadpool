### 一. IO密集型与CPU密集型

本文主要介绍一下什么是IO密集型程序，什么是CPU密集型程序；以及这两种类型的程序在单核及多核情况是否适用于多线程编程。

1. 什么是IO密集型与CPU密集型程序
   - **IO密集型程序**：程序在运行过程中执行的指令，其中涉及到一些`IO`操作，比如设备、文件、网络操作（等待客户端的链接）等，这些操作往往会使得当前程序阻塞住。
   - **CPU密集型程序**：程序里的指令都是做计算用的，比如一些用于科学计算、高性能计算的程序，举个简单的例子（从1一直加到10亿）等。
2. 单核情况下不同类型的程序对于多线程的适用
   - 单核的意思是说我的计算机只有一个核，对于多任务情况我只能采取并发运行。
   - 单核情况下的**IO密集型程序**使用多线程是合适的；
     - 原因是因为当我们的程序由于IO操作导致当前线程阻塞，如果此时还有CPU在该线程上停留，那此时CPU上空闲的，但是对于CPU来讲我们需要充分利用它的资源，它是不需要休息的，不如将CPU时间片分配给其他线程。所以说IO密集型程序适合设计成一个多线程的程序，可以充分的利用CPU。
   - 单核情况下的**CPU密集型程序**使用多线程是不合适的。
     - 原因是因为在单核多线程情况下一定会出现线程的调度，线程的调度是非常消耗时间的，这涉及到线程的上下文切换（见下文4）；但是对于我们CPU密集型的程序来讲我是希望我一直在计算而不是因为某种原因使我停下来，由于多线程调度出现线程间切换会耗时这种情况下多线程反而没有单线程更快，所以不适合。
3. 多核情况下不同类型的程序对于多线程的适用
   - 多核的意思是说我的计算机有多个核，可以理解为有多个CPU，可以并行多处理指令。对于多任务情况我可以采取并行和并发两种运行。
   - 多核情况下的IO密集型程序和CPU密集型程序对于多线程都是可以适用的，具体还是根据核的数量有关。它的解释类似于我们2中对于单核的解释。
   - 需要注意，我们的程序多线程的数量还是需要根据实际情况来决定。
4. 线程间切换
   - ![image-20230404203200051](/Users/fenghaining/work/fx_code/thread_learn/assets/image-20230404203200051.png)
   - 每个线程都有自己的线程栈和寄存器信息，当发生调度的时候会将当前运行线程的CPU环境（也就是寄存器信息）押入到自己的线程栈中，然后根据调度算法去就绪队列上选择一个线程将它的寄存器信息填入到当前的CPU寄存器中，然后CPU继续运行，这里只是简单介绍一下这个切换过程，实际会考虑到一些其他问题比这复杂很多。也就是说线程间切换是会消耗时间的。

------

### 二. 多线程的数量

为了完成任务，创建很多的线程可以吗？线程真的是越多越好吗？

- 线程的创建和销毁都是非常重的操作
- 线程栈本身占用大量内存
  - 一个线程需要内存（大概8M，当然可以修改），但是线程函数的执行还是需要空间；
  - 创建了一大堆线程，还没做具体的事情，每个线程都需要线程栈，栈几乎都被用完了，怎么做事情呢？
- 线程的上下文切换需要占用大量时间
  - 线程过多，线程的调度是需要进行上下文切换的，上下文切换花费的CPU时间也特别多，CPU的利用率也就低了，没时间去干具体业务了。
- 大量线程的同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机
  - 假设当同一时间，很多线程的IO操作准备好了，此时都被加入到就绪队列，这时大量线程会被唤醒，导致CPU和内存的占用率急剧提升，严重会使得我们的机器挂掉。
- 优秀的开源网络库他们的线程数量，一般都是按照当前CPU的核心数量来确定的。
  - C++的 muduo     libevent
  - Java的Netty    mina

------

### 三. 线程池的fixed和cached模式

- 为什么使用线程池?
  - 操作系统上创建线程和销毁线程都是很"重"的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。
  - 线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。
- **fixed模式**
  - 线程池里面的线程个数是固定不变的，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定。
- **cached模式**
  - 线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。

------

### 四. 线程同步

1. 线程互斥

- **竟态条件**
  - 代码段在多线程环境下执行，随着线程的调度顺序不同，而得到不同的运行结果！
- **可重入的**
  - 如果该代码段在多线程的情况下不存在竟态条件，则称为可重入的
- **不可重入的**
  - 如果该代码段在多线程的情况下存在竟态条件，则称为不可重入的
- 互斥锁
  - `lock_guard`
  - `unique_lock`
- atomic原子类型
  - CAS操作（无锁机制）

2. 线程通信















```
gdb attach (进程号)
info threads
bt
thread 5
```

